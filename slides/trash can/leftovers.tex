\begin{frame}[fragile]{Examples}
\begin{columns}
\column{0.3\textwidth}
\[\begin{tikzcd}
	A && B \\
	\\
	&& C &&&&& {}
	\arrow["{id_A}", from=1-1, to=1-1, loop, in=55, out=125, distance=10mm]
	\arrow["{f}", from=1-1, to=1-3]
	\arrow["{f \circ g}"', from=1-1, to=3-3]
	\arrow["{id_B}", from=1-3, to=1-3, loop, in=55, out=125, distance=10mm]
	\arrow["{g}", from=1-3, to=3-3]
	\arrow["{id_C}"', from=3-3, to=3-3, loop, in=305, out=235, distance=10mm]
\end{tikzcd}\]
\column{0.7\textwidth}
The Category $\mathbb{S}et$
\begin{itemize}
 \pause\item Objects are sets
 \pause\item A morphism $f \in \bC(A,B)$ is a function $A \to B$
 \pause\item The most important category for this talk (and arguably in general)
\end{itemize}
\end{columns}
\end{frame}
\begin{frame}[fragile]{Examples}
\begin{columns}
\column{0.3\textwidth}
% https://q.uiver.app/#q=WzAsNCxbMCwwLCIxIl0sWzIsMCwiMiJdLFsyLDIsIjMiXSxbNywyXSxbMCwxLCJmIDogMSBcXGxlcSAyIl0sWzEsMiwiZyA6IDIgXFxsZXEgMyJdLFswLDIsImYgXFxjaXJjIGcgOiAxIFxcbGVxIDMiLDJdLFswLDAsImlkXzEgOiAxIFxcbGVxIDEiXSxbMSwxLCJpZF8yIDogMiBcXGxlcSAyIl0sWzIsMiwiaWRfMyA6IDMgXFxsZXEgMyIsMix7InJhZGl1cyI6LTN9XV0=
\[\begin{tikzcd}
	1 && 2 \\
	\\
	&& 3 &&&&& {}
	\arrow["{id_1 : 1 \leq 1}", from=1-1, to=1-1, loop, in=55, out=125, distance=10mm]
	\arrow["{f : 1 \leq 2}", from=1-1, to=1-3]
	\arrow["{f \circ g : 1 \leq 3}"', from=1-1, to=3-3]
	\arrow["{id_2 : 2 \leq 2}", from=1-3, to=1-3, loop, in=55, out=125, distance=10mm]
	\arrow["{g : 2 \leq 3}", from=1-3, to\iffalse
\begin{frame}[fragile]{Examples}
\begin{columns}
\column{0.3\textwidth}
\[\begin{tikzcd}
	A && B \\
	\\
	&& C &&&&& {}
	\arrow["{id_A}", from=1-1, to=1-1, loop, in=55, out=125, distance=10mm]
	\arrow["{f}", from=1-1, to=1-3]
	\arrow["{f \circ g}"', from=1-1, to=3-3]
	\arrow["{id_B}", from=1-3, to=1-3, loop, in=55, out=125, distance=10mm]
	\arrow["{g}", from=1-3, to=3-3]
	\arrow["{id_C}"', from=3-3, to=3-3, loop, in=305, out=235, distance=10mm]
\end{tikzcd}\]
\column{0.7\textwidth}
The Category $\mathbb{S}et$
\begin{itemize}
 \pause\item Objects are sets
 \pause\item A morphism $f \in \bC(A,B)$ is a function $A \to B$
 \pause\item The most important category for this talk (and arguably in general)
\end{itemize}
\end{columns}
\end{frame}
\begin{frame}[fragile]{Examples}
\begin{columns}
\column{0.3\textwidth}
% https://q.uiver.app/#q=WzAsNCxbMCwwLCIxIl0sWzIsMCwiMiJdLFsyLDIsIjMiXSxbNywyXSxbMCwxLCJmIDogMSBcXGxlcSAyIl0sWzEsMiwiZyA6IDIgXFxsZXEgMyJdLFswLDIsImYgXFxjaXJjIGcgOiAxIFxcbGVxIDMiLDJdLFswLDAsImlkXzEgOiAxIFxcbGVxIDEiXSxbMSwxLCJpZF8yIDogMiBcXGxlcSAyIl0sWzIsMiwiaWRfMyA6IDMgXFxsZXEgMyIsMix7InJhZGl1cyI6LTN9XV0=
\[\begin{tikzcd}
	1 && 2 \\
	\\
	&& 3 &&&&& {}
	\arrow["{id_1 : 1 \leq 1}", from=1-1, to=1-1, loop, in=55, out=125, distance=10mm]
	\arrow["{f : 1 \leq 2}", from=1-1, to=1-3]
	\arrow["{f \circ g : 1 \leq 3}"', from=1-1, to=3-3]
	\arrow["{id_2 : 2 \leq 2}", from=1-3, to=1-3, loop, in=55, out=125, distance=10mm]
	\arrow["{g : 2 \leq 3}", from=1-3, to=3-3]
	\arrow["{id_3 : 3 \leq 3}"', from=3-3, to=3-3, loop, in=305, out=235, distance=10mm]
\end{tikzcd}\]
\column{0.7\textwidth}
Order Categories
\begin{itemize}
 \pause\item Let $S$ be a set with a partial ordering $\leq$
 \pause\item Objects are the elements of $S$
 \pause\item A morphism $f \in \bC(A,B)$ represents the fact $A \leq B$
\end{itemize}
\end{columns}
\end{frame}
%
%
%
\begin{frame}[fragile]{Haskell Functors}
\begin{itemize}
 \item In Haskell, a \textit{functor} is defined as an instance of the following typeclass:
 \pause\begin{verbatim}
  class Functor f where
    fmap :: (a -> b) -> f a -> f b
 \end{verbatim}
 \pause Where the following \textit{functor laws} are assumed to hold:
  \pause \begin{verbatim}
  fmap id = id
  fmap f (fmap g x) == fmap (f . g) x
 \end{verbatim}
\end{itemize}
\end{frame}
%
%
%

\begin{frame}[fragile]{Functors}
\begin{columns}
\column{0.3\textwidth}
% https://q.uiver.app/#q=WzAsNCxbMCwwLCJBIl0sWzAsMiwiRihBKSJdLFsyLDAsIkIiXSxbMiwyLCJGKEIpIl0sWzAsMSwiRiIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFswLDIsImYiLDJdLFsyLDMsIkYiLDIseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19XSxbMSwzLCJGKGYpIl1d
\[\begin{tikzcd}
	A && B \\
	\\
	{F(A)} && {F(B)}
	\arrow["f"', from=1-1, to=1-3]
	\arrow["{F(f)}", from=3-1, to=3-3]
\end{tikzcd}\]
\column{0.7\textwidth}
\begin{itemize}
 \item General Functors are almost identical to Haskell Functors.
 \pause\item In general, a functor is a map $F : \bC \to \bD$.
 \begin{itemize}
  \pause\item An object $A \in |\bC|$ is mapped to an object $F(A) \in |\bD|$
  \pause\item A morphism $f \in \bC(A,B)$ is mapped to a morphism $F(f) \in \bD(F(A), F(B))$
 \end{itemize}
 \pause\item Functors are structure preserving.
 \begin{itemize}
  \pause\item $F(id_A) = id_{F(A)}$
  \pause\item $F(f \circ g) = F(f) \circ F(g)$
 \end{itemize}
\end{itemize}
\end{columns}
\end{frame}
\begin{frame}[fragile]{Functors in Programming}
 \begin{verbatim}
     data Maybe a = Nothing | Just a
 \end{verbatim}
 \begin{itemize}
  \item \texttt{Maybe} defines a functor $\texttt{Maybe} : \mathbb{S}et \to \mathbb{S}et$
  \item A set \texttt{a} is mapped to a set \texttt{Maybe a}
  \item Given a function $f : a \to b$, we can define a function $\texttt{Maybe}\ f : \texttt{Maybe}\ a \to \texttt{Maybe}\ b$  as follows:
  \begin{align*}
   \texttt{Maybe}\ f(a) = \begin{cases}
                           \texttt{Nothing} & \texttt{Maybe}\ a  = \texttt{Nothing}\\
                           \texttt{Just}\ f(a) & \texttt{Maybe}\ a  = \texttt{Just}\ a\\
                          \end{cases}
  \end{align*}
  \item In Haskell notation:
  \begin{verbatim}
    fmap :: (a -> b) -> Maybe a -> Maybe b
    fmap _ Nothing = Nothing
    fmap f (Just x) = Just (f x)
  \end{verbatim}

 \end{itemize}
\end{frame}
\fi=3-3]
	\arrow["{id_3 : 3 \leq 3}"', from=3-3, to=3-3, loop, in=305, out=235, distance=10mm]
\end{tikzcd}\]
\column{0.7\textwidth}
Order Categories
\begin{itemize}
 \pause\item Let $S$ be a set with a partial ordering $\leq$
 \pause\item Objects are the elements of $S$
 \pause\item A morphism $f \in \bC(A,B)$ represents the fact $A \leq B$
\end{itemize}
\end{columns}
\end{frame}
%
%
%
\begin{frame}[fragile]{Haskell Functors}
\begin{itemize}
 \item In Haskell, a \textit{functor} is defined as an instance of the following typeclass:
 \pause\begin{verbatim}
  class Functor f where
    fmap :: (a -> b) -> f a -> f b
 \end{verbatim}
 \pause Where the following \textit{functor laws} are assumed to hold:
  \pause \begin{verbatim}
  fmap id = id
  fmap f (fmap g x) == fmap (f . g) x
 \end{verbatim}
\end{itemize}
\end{frame}
%
%
%

\begin{frame}[fragile]{Functors}
\begin{columns}
\column{0.3\textwidth}
% https://q.uiver.app/#q=WzAsNCxbMCwwLCJBIl0sWzAsMiwiRihBKSJdLFsyLDAsIkIiXSxbMiwyLCJGKEIpIl0sWzAsMSwiRiIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFswLDIsImYiLDJdLFsyLDMsIkYiLDIseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19XSxbMSwzLCJGKGYpIl1d
\[\begin{tikzcd}
	A && B \\
	\\
	{F(A)} && {F(B)}
	\arrow["f"', from=1-1, to=1-3]
	\arrow["{F(f)}", from=3-1, to=3-3]
\end{tikzcd}\]
\column{0.7\textwidth}
\begin{itemize}
 \item General Functors are almost identical to Haskell Functors.
 \pause\item In general, a functor is a map $F : \bC \to \bD$.
 \begin{itemize}
  \pause\item An object $A \in |\bC|$ is mapped to an object $F(A) \in |\bD|$
  \pause\item A morphism $f \in \bC(A,B)$ is mapped to a morphism $F(f) \in \bD(F(A), F(B))$
 \end{itemize}
 \pause\item Functors are structure preserving.
 \begin{itemize}
  \pause\item $F(id_A) = id_{F(A)}$
  \pause\item $F(f \circ g) = F(f) \circ F(g)$
 \end{itemize}
\end{itemize}
\end{columns}
\end{frame}
\begin{frame}[fragile]{Functors in Programming}
 \begin{verbatim}
     data Maybe a = Nothing | Just a
 \end{verbatim}
 \begin{itemize}
  \item \texttt{Maybe} defines a functor $\texttt{Maybe} : \mathbb{S}et \to \mathbb{S}et$
  \item A set \texttt{a} is mapped to a set \texttt{Maybe a}
  \item Given a function $f : a \to b$, we can define a function $\texttt{Maybe}\ f : \texttt{Maybe}\ a \to \texttt{Maybe}\ b$  as follows:
  \begin{align*}
   \texttt{Maybe}\ f(a) = \begin{cases}
                           \texttt{Nothing} & \texttt{Maybe}\ a  = \texttt{Nothing}\\
                           \texttt{Just}\ f(a) & \texttt{Maybe}\ a  = \texttt{Just}\ a\\
                          \end{cases}
  \end{align*}
  \item In Haskell notation:
  \begin{verbatim}
    fmap :: (a -> b) -> Maybe a -> Maybe b
    fmap _ Nothing = Nothing
    fmap f (Just x) = Just (f x)
  \end{verbatim}

 \end{itemize}
\end{frame}
